# 📕 Solution

벽에 닿아서 방향이 바뀌는 것을 굳이 점화식을 만들어서 풀 필요가 없습니다.  
항상 구현이 더 쉬운 것은 구현으로 합니다!!💪💪

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.StringTokenizer;
import java.util.Collections;

class Shark {
    int row;
    int column;
    int speed;
    int direction;
    int size;

    Shark(int row, int column, int speed, int direction, int size) {
        this.row = row;
        this.column = column;
        this.speed = speed;
        this.direction = direction;
        this.size = size;
    }
} // 상어 객체 생성

class Main {
    public static int R, C, M, answer;
    public static int[][] arr;
    public static ArrayList<Shark> shark;
    public static final int[][] direction = { { 0, 0 }, { -1, 0 }, { 1, 0 }, { 0, 1 }, { 0, -1 } };

    public static void fishing(int num) {
        M = shark.size();
        ArrayList<Integer> same_column = new ArrayList<Integer>();
        for (int i = 0; i < M; i++) {
            Shark node = shark.get(i);
            if (num == node.column) {
                same_column.add(i);
            } // 같은 column인 상어를 찾습니다.
        }
        int result = R + 1, index = -1, Size = same_column.size();
        if (Size == 0)
            return;
        for (Integer i : same_column) {
            if (result > shark.get(i).row) {
                result = shark.get(i).row;
                index = i;
            }
        } // 땅과 제일 가까운 상어를 선택
        if (index != -1) {
            answer += shark.get(index).size;
            // System.out.println("FISH: " + shark.get(index).size);
            shark.remove(index);
        }
        return;
    }

    public static void moveShark() {
        M = shark.size();
        for (int i = 0; i < M; i++) {
            Shark node = shark.get(i);
            int[] direct = direction[node.direction];
            if (direct[0] != 0) {
                int b = node.speed % (2 * R - 2); // 해당 주기는 2 * R - 2입니다.
                for (int j = 0; j < b; j++) {
                    if (node.row + direct[0] <= 0 || node.row + direct[0] > R) {
                        if (node.direction == 1) {
                            node.direction = 2;
                        } else {
                            node.direction = 1;
                        } // 벽에 닿으면 방향을 바꿔줍니다.
                    }
                    direct = direction[node.direction]; // node.direction을 바꾸고 나면 직접 update를 해줘야 합니다.
                    node.row += direct[0];
                }
            }
            if (direct[1] != 0) {
                int b = node.speed % (2 * C - 2); // 해당 주기는 2 * C - 2입니다.
                for (int j = 0; j < b; j++) {
                    if (node.column + direct[1] <= 0 || node.column + direct[1] > C) {
                        if (node.direction == 3) {
                            node.direction = 4;
                        } else {
                            node.direction = 3;
                        } // 벽에 닿으면 방향을 바꿔줍니다.
                    }
                    direct = direction[node.direction]; // node.direction을 바꾸고 나면 직접 update를 해줘야 합니다.
                    node.column += direct[1];
                }
            }
        }
    }

    public static void removeShark() {
        Collections.sort(shark, new Comparator<Shark>() {
            @Override
            public int compare(Shark s1, Shark s2) {
                if (s1.row == s2.row) {
                    return s1.column - s2.column;
                }
                return s1.row - s2.row;
            } // 오름차순으로 정렬합니다.
        });
        for (int i = 0; i < shark.size() - 1;) {
            Shark node = shark.get(i);
            Shark next = shark.get(i + 1);
            if (node.row == next.row && node.column == next.column) {
                if (node.size > next.size) {
                    shark.remove(next);
                } else {
                    shark.remove(node);
                } // 크기에 따른 상어 제거합니다.
            } else {
                i++; // 제거를 하지 않으면 다음 index를 확인합니다.
            }
        }
    }

    public static void printShark() {
        M = shark.size();
        for (int i = 0; i < M; i++) {
            Shark node = shark.get(i);
            // System.out.println(node.row + " " + node.column + " " + node.speed + " " +
            // node.direction + " " + node.size);
        }
    }

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine(), " ");
        R = Integer.parseInt(st.nextToken());
        C = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());
        arr = new int[R + 1][C + 1];
        shark = new ArrayList<Shark>();
        for (int i = 0; i < M; i++) {
            st = new StringTokenizer(br.readLine(), " ");
            int r = Integer.parseInt(st.nextToken());
            int c = Integer.parseInt(st.nextToken());
            int s = Integer.parseInt(st.nextToken());
            int d = Integer.parseInt(st.nextToken());
            int z = Integer.parseInt(st.nextToken());
            shark.add(new Shark(r, c, s, d, z));
        }
        answer = 0;
        for (int i = 1; i <= C; i++) {
            fishing(i);
            moveShark();
            removeShark();
            // System.out.println("PRINT: " + i);
            // printShark();
        }
        System.out.println(answer);
        br.close();
    }
}
```

# ❌ Fail

벽에 부딪혀서 방향이 바꾸는 것을 굳이 수학 공식을 이용해서 만들 필요가 없습니다.😑😑

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.StringTokenizer;

class Main {
    public static int R, C;
    public static int[][] arr;
    public static ArrayList<ArrayList<Integer>> shark;
    public static final int[][] direction = { { 0, 0 }, { -1, 0 }, { 1, 0 }, { 0, 1 }, { 0, -1 } };

    public static int calculator(int num, int N) {
        int answer = num % (2 * N - 2);
        if (answer < 0) {
            answer += 2 * N - 2;
        }
        if (answer == 0) {
            return 2;
        }
        if (answer >= 1 && answer <= N) {
            return answer;
        } else {
            return 2 * N - answer;
        }
    }

    public static void moveShark() {
        for (int i = 0; i < shark.size(); i++) {
            int[] direct = direction[shark.get(i).get(3)];
            int row_index = calculator(shark.get(i).get(0) + direct[0] * shark.get(i).get(2), R);
            int column_index = calculator(shark.get(i).get(1) + direct[1] * shark.get(i).get(2), C);
            shark.get(i).set(0, row_index);
            shark.get(i).set(1, column_index);
        }
    }

    public static void removeShark() {
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < shark.size(); i++) {
            int column = shark.get(i).get(1);
            if (!map.containsKey(column)) {
                map.put(column, i);
            } else {
                int k = map.get(column);
                if (shark.get(k).get(4) < shark.get(i).get(4)) {
                    System.out.println("D2: " + shark.get(k).get(4));
                    shark.remove(k);
                    map.put(column, i);
                    break;
                }
            }
        }
    }

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine(), " ");
        R = Integer.parseInt(st.nextToken());
        C = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());
        arr = new int[R + 1][C + 1];
        shark = new ArrayList<>();
        for (int i = 0; i < M; i++) {
            st = new StringTokenizer(br.readLine(), " ");
            ArrayList<Integer> element = new ArrayList<>();
            for (int j = 0; j < 5; j++) {
                element.add(Integer.parseInt(st.nextToken()));
            }
            shark.add(element);
        }
        int answer = 0;

        for (int man = 1; man <= C; man++) {
            int catchShark = R + 1, index = -1;
            for (int i = 0; i < shark.size(); i++) {
                if (shark.get(i).get(1) == man && shark.get(i).get(0) < catchShark) {
                    catchShark = shark.get(i).get(0);
                    index = i;
                }
            }
            if (catchShark != R + 1) {
                answer += shark.get(index).get(4);
                System.out.println("D1: " + shark.get(index).get(4));
                shark.remove(index);
            }
            moveShark();
            removeShark();
        }
        System.out.println(answer);
        br.close();
    }
}
```
