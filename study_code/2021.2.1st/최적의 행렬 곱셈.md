# 📕 Solution

해당 범위에 대한 전체 계산

```java
class Solution {
    public int solution(int[][] matrix_sizes) {
        int answer = 0, size = matrix_sizes.length + 1;
        int[][] dp = new int[size][size];
        int[] arr = new int[size];
        arr[0] = matrix_sizes[0][0];
        for(int i = 1; i < size; i++){
            arr[i] =  matrix_sizes[i - 1][1];
        }
        for(int interval = 1; interval < size; interval++){
            for(int j = 1; j + interval < size; j++){
                int x = j;
                int y = j + interval;
                dp[x][y] = Integer.MAX_VALUE;
                for(int k = x; k < y; k++){
                    dp[x][y] = Math.min(dp[x][y], dp[x][k] + dp[k + 1][y] + arr[x - 1] * arr[k] * arr[y]);
                }
            }
        }
        return dp[1][size - 1];
    }
}
```

## ❌ fail

문제점 : (1, 2) -> (3,4) -> ((1, 2), (3, 4)) 순으로 계산이 가능한데, 이를 배제했습니다.

```java
class Solution {
    public int solution(int[][] matrix_sizes) {
        int answer = 0, size = matrix_sizes.length;
        int[][] dp = new int[size][size];
        for(int interval = 1; interval < size; interval++){
            for(int j = 0; j + interval < size; j++){
                int x = j;
                int y = j + interval;
                int toLeft = matrix_sizes[x][0] * matrix_sizes[y][0] * matrix_sizes[y][1] + dp[x][y - 1];
                int toTop = matrix_sizes[x][0] * matrix_sizes[x][1] * matrix_sizes[y][1] + dp[x + 1][y];
                dp[x][y] = Math.min(toLeft, toTop);

            }
        }
        return dp[0][size - 1];
    }
}
```
