# ğŸ“• Solution

## :memo: ë¬¸ì œ ì„¤ëª…

1. 2ì°¨ì› ë²½ë©´ì€ n x n í¬ê¸° ì •ì‚¬ê° ê²©ì í˜•íƒœì´ë©°, ê° ê²©ìëŠ” 1 x 1 í¬ê¸°ì…ë‹ˆë‹¤.
2. ê¸°ë‘¥ì€ ë°”ë‹¥ ìœ„ì— ìˆê±°ë‚˜ ë³´ì˜ í•œìª½ ë ë¶€ë¶„ ìœ„ì— ìˆê±°ë‚˜, ë˜ëŠ” ë‹¤ë¥¸ ê¸°ë‘¥ ìœ„ì— ìˆì–´ì•¼ í•©ë‹ˆë‹¤.
3. ë³´ëŠ” í•œìª½ ë ë¶€ë¶„ì´ ê¸°ë‘¥ ìœ„ì— ìˆê±°ë‚˜, ë˜ëŠ” ì–‘ìª½ ë ë¶€ë¶„ì´ ë‹¤ë¥¸ ë³´ì™€ ë™ì‹œì— ì—°ê²°ë˜ì–´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.
4. 2ì°¨ì› ë°°ì—´ build_frameì´ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, ëª¨ë“  ëª…ë ¹ì–´ë¥¼ ìˆ˜í–‰í•œ í›„ êµ¬ì¡°ë¬¼ì˜ ìƒíƒœë¥¼ returní•˜ì„¸ìš”!

## ğŸ‘» ì ‘ê·¼ ë°©ì‹

Pairë¼ëŠ” classë¥¼ ë§Œë“¤ì–´ì„œ ê¸°ë‘¥ê³¼ ë³´ë¥¼ ë§Œë“¤ë©´ì„œ ìƒì„±ë˜ëŠ” ì¢Œí‘œë“¤ì„ ì €ì¥í•´ì„œ ê¸°ë‘¥ê³¼ ë³´ì˜ ìƒì„±, ì‚­ì œë¥¼ ì§„í–‰í•©ë‹ˆë‹¤.

## âŒ fail

ë¬¸ì œì  : pairë¥¼ ê³„ì† ë§Œë“¤ë©´ì„œ í™•ì¸í•˜ë©´, í•´ë‹¹ pairê°€ ìˆëŠ”ì§€ í™•ì¸í•˜ë ¤ë©°ëŠ ë„ˆë¬´ ë§ì€ ì‹œê°„ì´ ì†Œìš”ë˜ì„œ ì¤‘ê°„ì— êµ¬í˜„ì„ ë©ˆì·„ìŠµë‹ˆë‹¤.

```java
import java.util.*;

class Pair {
    int x;
    int y;
    Pair(int x, int y){
        this.x = x;
        this.y = y;
    }
}
class Solution {
    public boolean isContain(int a, int b, ArrayList<Pair> arr){
        for(Pair pair : arr){
            if(pair.x == a && pair.y == b){
                return true;
            }
        }
        return false;
    }
    public int[][] solution(int n, int[][] build_frame) {
        int[][] wall = new int[n+1][n+1];
        int size = build_frame.length;
        ArrayList<Pair> arr = new ArrayList<Pair>();
        for(int i = 0; i < size; i++){
            if(build_frame[i][3] == 1){
                if(build_frame[i][2] == 0){
                    if(arr.isEmpty()){
                        arr.add(new Pair(build_frame[i][0], build_frame[i][1]));
                        arr.add(new Pair(build_frame[i][0], build_frame[i][1] + 1));
                        continue;
                    }
                    if(build_frame[i][1] == 0 || isContain(build_frame[i][0], build_frame[i][1], arr)){
                        arr.add(new Pair(build_frame[i][0], build_frame[i][1] + 1));
                    } else {
                        continue;
                    }
                } // ê¸°ë‘¥
                if(build_frame[i][2] == 1){
                    if(build_frame[i][0] != 0 && isContain(build_frame[i][0], build_frame[i][1], arr)){
                        arr.add(new Pair(build_frame[i][0] + 1, build_frame[i][1]));
                    } else {
                        continue;
                    }
                } // ë³´
            } // ì„¤ì¹˜
            if(build_frame[i][3] == 0){
                if(build_frame[i][2] == 0){

                } // ê¸°ë‘¥
                if(build_frame[i][2] == 1){

                } // ë³´
            } // ì‚­ì œ
        }
        Collections.sort(arr, new Comparator<Pair>(){
            @Override
            public int compare(Pair o1, Pair o2){
                if(o1.x == o2.x){
                    return o1.y - o2.y;
                }
                return o1.x - o2.x;
            }
        });
        int Size = arr.size();
        int[][] answer = new int[Size - 1][3];
        for(int i = 0; i < Size - 1; i++){
            if(arr.get(i).x == arr.get(i + 1).x){
                answer[i][0] = arr.get(i).x;
                answer[i][1] = Math.min(arr.get(i).y, arr.get(i + 1).y);
                answer[i][2] = 0; // ê¸°ë‘¥
            } else if(arr.get(i).y == arr.get(i + 1).y){
                answer[i][0] = arr.get(i).x;
                answer[i][1] = arr.get(i).y;
                answer[i][2] = 1; // ë³´
            }
            System.out.println("D: " + arr.get(i).x + " " + arr.get(i).y);
            System.out.println(answer[i][0] + " " + answer[i][1] + " " + answer[i][2]);
        }
        return answer;
    }
}
```

## ğŸ’ª í’€ì´ ë°©ë²•

1. 2ì°¨ì› ë²½ë©´ì€ n x n í¬ê¸° ì •ì‚¬ê° ê²©ì í˜•íƒœì´ë©°, ê° ê²©ìëŠ” 1 x 1 í¬ê¸°ì…ë‹ˆë‹¤.

```java
columns = new boolean[n + 3][n + 3]; // 1 ~ n + 1 ê¹Œì§€ ì‚¬ìš©
beams = new boolean[n + 3][n + 3]; // 1 ~ n + 1 ê¹Œì§€ ì‚¬ìš©
```

2. ê¸°ë‘¥ì€ ë°”ë‹¥ ìœ„ì— ìˆê±°ë‚˜ ë³´ì˜ í•œìª½ ë ë¶€ë¶„ ìœ„ì— ìˆê±°ë‚˜, ë˜ëŠ” ë‹¤ë¥¸ ê¸°ë‘¥ ìœ„ì— ìˆì–´ì•¼ í•©ë‹ˆë‹¤.

```java
public boolean canBuildColumn(int x, int y){
    if(y == 1 || columns[x][y - 1] || beams[x - 1][y] || beams[x][y])
        return true;
    return false;
}
```

3. ë³´ëŠ” í•œìª½ ë ë¶€ë¶„ì´ ê¸°ë‘¥ ìœ„ì— ìˆê±°ë‚˜, ë˜ëŠ” ì–‘ìª½ ë ë¶€ë¶„ì´ ë‹¤ë¥¸ ë³´ì™€ ë™ì‹œì— ì—°ê²°ë˜ì–´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.

```java
public boolean canBuildBeam(int x, int y){
    if(columns[x][y - 1] || columns[x + 1][y - 1] || (beams[x - 1][y] && beams[x + 1][y]))
        return true;
    return false;
}
```

4. ì‚­ì œë¥¼ í™•ì¸í•˜ëŠ” ë°©ë²•ì€ í•´ë‹¹ ê¸°ë‘¥ê³¼ ë³´ì— ëŒ€í•œ dataë¥¼ ì§€ìš°ê³  ë‚¨ì€ ë‚˜ë¨¸ì§€ êµ¬ì¡°ë¬¼ì´ ì í•©í•œ êµ¬ì¡°ë¬¼ì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤.

```java
public boolean canDelete(int x, int y, int n){
    for(int i = 1; i <= n + 1; i++){
        for(int j = 1; j <= n + 1; j++){
            if(columns[i][j] && !canBuildColumn(i, j)){
                return false;
            }
            if(beams[i][j] && !canBuildBeam(i, j)){
                return false;
            }
        }
    }
    return true;
}
```

5. 2ì°¨ì› ë°°ì—´ build_frameì´ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, ëª¨ë“  ëª…ë ¹ì–´ë¥¼ ìˆ˜í–‰í•œ í›„ êµ¬ì¡°ë¬¼ì˜ ìƒíƒœë¥¼ returní•˜ì„¸ìš”!

```java
for(int i = 1; i <= n + 1; i++){
    for(int j = 1; j <= n + 1; j++){
        if(columns[i][j]){
            answer[count++] = new int[]{i - 1, j - 1, 0};
            // ì •ë‹µì„ ë„£ì„ ë•, 1ì„ ë¹¼ì¤ë‹ˆë‹¤.
        }
        if(beams[i][j]){
            answer[count++] = new int[]{i - 1, j - 1, 1};
            // ì •ë‹µì„ ë„£ì„ ë•, 1ì„ ë¹¼ì¤ë‹ˆë‹¤.
        }
    }
}
```

## ğŸ‘» About

êµ¬í˜„ë¬¸ì œëŠ” ë¬¸ì œ ê·¸ëŒ€ë¡œ ì¡°ê±´ì„ í’‰ì‹œë‹¤!

## âœˆ Explain Code

```java
class Solution {
    public boolean[][] columns, beams;
    public boolean canBuildColumn(int x, int y){
        if(y == 1 || columns[x][y - 1] || beams[x - 1][y] || beams[x][y]) return true;
        return false;
    }
    public boolean canBuildBeam(int x, int y){
        if(columns[x][y - 1] || columns[x + 1][y - 1] || (beams[x - 1][y] && beams[x + 1][y])) return true;
        return false;
    }
    public boolean canDelete(int x, int y, int n){
        for(int i = 1; i <= n + 1; i++){
            for(int j = 1; j <= n + 1; j++){
                if(columns[i][j] && !canBuildColumn(i, j)){
                    return false;
                }
                if(beams[i][j] && !canBuildBeam(i, j)){
                    return false;
                }
            }
        }
        return true;
    }
    public int[][] solution(int n, int[][] build_frame) {
        int build_count = 0;
        columns = new boolean[n + 3][n + 3];
        beams = new boolean[n + 3][n + 3];
        for(int[] element : build_frame){
            int x = element[0] + 1;
            int y = element[1] + 1;
            int howToBuild = element[2]; // 0ì€ ê¸°ë‘¥, 1ì€ ë³´
            int buildOrDelete = element[3]; // 0ì€ ì‚­ì œ, 1ì€ ì„¤ì¹˜
            if(buildOrDelete == 0){
                if(howToBuild == 0){
                    columns[x][y] = false;
                    if(canDelete(x, y, n)){
                        build_count--;
                        continue;
                    }
                    columns[x][y] = true;
                } else if(howToBuild == 1){
                    beams[x][y] = false;
                    if(canDelete(x, y, n)){
                        build_count--;
                        continue;
                    }
                    beams[x][y] = true;
                }
            } else if(buildOrDelete == 1){
                if(howToBuild == 0 && canBuildColumn(x, y)){
                    columns[x][y] = true;
                    build_count++;
                } else if(howToBuild == 1 && canBuildBeam(x, y)){
                    beams[x][y] = true;
                    build_count++;
                }
            }
        }
        int[][] answer = new int[build_count][3];
        int count = 0;
        for(int i = 1; i <= n + 1; i++){
            for(int j = 1; j <= n + 1; j++){
                if(columns[i][j]){
                    answer[count++] = new int[]{i - 1, j - 1, 0};
                }
                if(beams[i][j]){
                    answer[count++] = new int[]{i - 1, j - 1, 1};
                }
            }
        }
        return answer;
    }
}
```

## âœˆ Source Code

```java
class Solution {
    public boolean[][] columns, beams;
    public boolean canBuildColumn(int x, int y){
        if(y == 1 || columns[x][y - 1] || beams[x - 1][y] || beams[x][y]) return true;
        return false;
    }
    public boolean canBuildBeam(int x, int y){
        if(columns[x][y - 1] || columns[x + 1][y - 1] || (beams[x - 1][y] && beams[x + 1][y])) return true;
        return false;
    }
    public boolean canDelete(int x, int y, int n){
        for(int i = 1; i <= n + 1; i++){
            for(int j = 1; j <= n + 1; j++){
                if(columns[i][j] && !canBuildColumn(i, j)){
                    return false;
                }
                if(beams[i][j] && !canBuildBeam(i, j)){
                    return false;
                }
            }
        }
        return true;
    }
    public int[][] solution(int n, int[][] build_frame) {
        int build_count = 0;
        columns = new boolean[n + 3][n + 3];
        beams = new boolean[n + 3][n + 3];
        for(int[] element : build_frame){
            int x = element[0] + 1;
            int y = element[1] + 1;
            int howToBuild = element[2];
            int buildOrDelete = element[3];
            if(buildOrDelete == 0){
                if(howToBuild == 0){
                    columns[x][y] = false;
                    if(canDelete(x, y, n)){
                        build_count--;
                        continue;
                    }
                    columns[x][y] = true;
                } else if(howToBuild == 1){
                    beams[x][y] = false;
                    if(canDelete(x, y, n)){
                        build_count--;
                        continue;
                    }
                    beams[x][y] = true;
                }
            } else if(buildOrDelete == 1){
                if(howToBuild == 0 && canBuildColumn(x, y)){
                    columns[x][y] = true;
                    build_count++;
                } else if(howToBuild == 1 && canBuildBeam(x, y)){
                    beams[x][y] = true;
                    build_count++;
                }
            }
        }
        int[][] answer = new int[build_count][3];
        int count = 0;
        for(int i = 1; i <= n + 1; i++){
            for(int j = 1; j <= n + 1; j++){
                if(columns[i][j]){
                    answer[count++] = new int[]{i - 1, j - 1, 0};
                }
                if(beams[i][j]){
                    answer[count++] = new int[]{i - 1, j - 1, 1};
                }
            }
        }
        return answer;
    }
}
```

## âœ” íšŒê³ 

êµ¬í˜„ ë¬¸ì œëŠ” ì—­ì‹œ ë¬¸ì œ ì¡°ê±´ ê·¸ëŒ€ë¡œ í‘¸ëŠ” ê²ƒì´ ì •ë‹µì´ë¼ê³  ìƒê°í•©ë‹ˆë‹¤.ğŸ‘ğŸ‘
