# ğŸ“• Solution

## :memo: ë¬¸ì œ ì„¤ëª…

1. Nëª…ì˜ ì‚¬ëŒë“¤ê³¼ ë§ˆí”¼ì•„ ê²Œì„ì„ í•©ë‹ˆë‹¤.
2. ë§ˆí”¼ì•„ê°€ ìµœëŒ€ ëª‡ ëª…ì´ë‚˜ ë‚˜ì˜¬ ìˆ˜ ìˆëŠ”ì§€ returní•˜ì„¸ìš”.

> Hint :

1. ì²« ë²ˆì§¸ ì˜ˆì œì—ì„œ ë§ˆí”¼ì•„ì¼ ê²ƒì´ë¼ê³  ìƒê°ë˜ëŠ” ì°¸ê°€ìëŠ” 2ë²ˆê³¼ 3ë²ˆì´ë‹¤.
2. ë‘ ë²ˆì§¸ ì˜ˆì œì—ì„œëŠ” ì–´ëŠ ëˆ„êµ¬ë‚˜ ë§ˆí”¼ì•„ë¡œ ìƒê°ë  ìˆ˜ ìˆë‹¤.
3. ë§ˆí”¼ì•„ë¼ë¦¬ëŠ” ì„œë¡œ ëˆ„êµ°ì§€ ì•„ëŠ” ìƒí™©ì´ê¸° ë•Œë¬¸ì— ì„œë¡œ ì§€ëª©ì„ ì•ˆ í•˜ë ¤ê³  í•  ê²ƒì´ë‹¤.

## ğŸ‘» ì ‘ê·¼ ë°©ì‹

ì–´ë–»ê²Œ í’€ì–´ì•¼ í• ì§€ ê³„ì† ìƒê°í•´ë„ ì˜ ëª¨ë¥´ê² ì–´ì„œ ì•„ì´ë””ì–´ë§Œ í™•ì¸í•˜ì—¬ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤.

ì°¸ê³  ì‚¬ì´íŠ¸ : [Go to Link](https://slllju.tistory.com/67)

ê²°ê³¼ : ì„±ê³µ â–¶ Runtime : 1436ms

1. ì§€ëª©í•œ ì‚¬ëŒê³¼ ì§€ëª© ë‹¹í•œ ì‚¬ëŒë“¤ì„ ê°„ì„ ì„ ì–‘ë°©í–¥ìœ¼ë¡œ ì´ì–´ì¤ë‹ˆë‹¤.

```java
for (int i = 1; i <= N; i++) {
    int num = Integer.parseInt(br.readLine());
    whoPoint[i] = num;
    if (Graph.get(i).contains(num)) {
        continue;
    }
    countAdj[i]++;
    countAdj[num]++;
    Graph.get(i).add(num);
    Graph.get(num).add(i);
}
```

2. dfsë¥¼ ì´ìš©í•´ì„œ Groupingì„ í•´ì¤ë‹ˆë‹¤.

```java
// grouping
ArrayList<ArrayList<Integer>> Grouping = new ArrayList<ArrayList<Integer>>();
int grouping = 0;
for (int i = 1; i <= N; i++) {
    if (groupNumber[i] == 0) {
        dfs(i, ++grouping);
    }
}
for (int i = 0; i <= grouping; i++) {
    Grouping.add(new ArrayList<>());
}
for (int i = 1; i <= N; i++) {
    Grouping.get(groupNumber[i]).add(i);
}
```

```java
public static void dfs(int index, int grouping) {
    if (groupNumber[index] != 0) {
        return;
    }
    groupNumber[index] = grouping;
    for (Integer i : Graph.get(index)) {
        dfs(i, grouping);
    }
} // Groupingì„ í•  ë•Œ, ì‚¬ìš©í•˜ëŠ” dfs
```

3. ë§ˆí”¼ì•„ê°€ í•­ìƒ ê°€ëŠ¥í•œ ì‚¬ëŒë“¤ì€ 2ê°€ì§€ê°€ ì¡´ì¬í•©ë‹ˆë‹¤. </br> 1. ì•„ë¬´ ì‚¬ëŒì—ê²Œë„ ì§€ëª©ì„ ë°›ì§€ ì•Šì€ ì‚¬ëŒ(=leafNode) </br> 2. ì‚¬ì´í´ì´ ì¡´ì¬í•˜ëŠ” ê²½ìš°, ê·¸ ì¤‘ ì•„ë¬´ë‚˜ í•œ ì‚¬ëŒ </br> Ex) 1 -> 2, 2 -> 3, 3 -> 1 ìœ¼ë¡œ ì§€ëª©ì´ ë˜ë©´ 1, 2, 3 ì¤‘ ì•„ë¬´ë‚˜ í•œ ì‚¬ëŒì´ ë§ˆí”¼ì•„ê°€ ë˜ë„ ìƒê´€ì—†ìŠµë‹ˆë‹¤.

```java
// bfs init => leadfNode add
Queue<Integer> queue = new LinkedList<Integer>();
for (int i = 1; i <= N; i++) {
    if (countAdj[i] <= 1) {
        queue.offer(i);
        check[i] = true;
    }
}
```

```java
// cycle ì—¬ë¶€ í™•ì¸
for (int i = 1; i <= grouping; i++) {
    boolean isCycle = true;
    for (Integer j : Grouping.get(i)) {
        if (countAdj[j] != 2) {
            isCycle = false;
        }
    }
    if (isCycle) {
        queue.offer(Grouping.get(i).get(0));
        check[Grouping.get(i).get(0)] = true;
    }
}
```

4. ë§ˆí”¼ì•„ê°€ ê°€ëŠ¥í•œ ì‚¬ëŒë“¤ì„ queueì— ë„£ê³  ë§ˆí”¼ì•„ì™€ ì¸ì ‘í•œ ì‚¬ëŒë“¤ì€ ë¬´ì¡°ê±´ ì‹œë¯¼ìœ¼ë¡œ, ê·¸ ë‹¤ìŒ ì‹œë¯¼ê³¼ ì¸ì ‘í•œ ì‚¬ëŒë“¤ ì¤‘ ë°©ë¬¸í•˜ì§€ ì•Šì€ ì‚¬ëŒë“¤ì€ ë§ˆí”¼ì•„ë¡œ ì§€ëª©í•©ë‹ˆë‹¤. </br> **(= ë§ˆí”¼ì•„ ìˆ˜ë¥¼ ìµœëŒ€ë¡œ ë§Œë“¤ê¸° ìœ„í•´ì„œ)**

```java
// find Mafia
int answer = 0;
boolean[] isCitizen = new boolean[N + 1];
while (!queue.isEmpty()) {
    int node = queue.poll();
    if (isCitizen[node]) {
        continue;
    }
    answer++;
    for (Integer i : Graph.get(node)) {
        if (isCitizen[i]) {
            continue;
        }
        isCitizen[i] = true;
        for (Integer j : Graph.get(i)) {
            if (isCitizen[j] || check[j]) {
                continue;
            }
            countAdj[j]--;
            if (countAdj[j] <= 1) {
                check[j] = true;
                queue.offer(j);
            }
        }
    }
}
System.out.println(answer);
br.close();
```

5. ì €ì¥í•œ ìµœëŒ€ ìˆ˜ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

## âœˆ Explain Code

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;

class Main {
    public static ArrayList<ArrayList<Integer>> Graph;
    public static int[] groupNumber;

    public static void dfs(int index, int grouping) {
        if (groupNumber[index] != 0) {
            return;
        }
        groupNumber[index] = grouping;
        for (Integer i : Graph.get(index)) {
            dfs(i, grouping);
        }
    } // Groupingì„ í•  ë•Œ, ì‚¬ìš©í•˜ëŠ” dfs

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());
        Graph = new ArrayList<ArrayList<Integer>>();
        int[] whoPoint = new int[N + 1];
        int[] countAdj = new int[N + 1];
        groupNumber = new int[N + 1];
        boolean[] check = new boolean[N + 1];
        for (int i = 0; i <= N; i++) {
            Graph.add(new ArrayList<>());
        }
        for (int i = 1; i <= N; i++) {
            int num = Integer.parseInt(br.readLine());
            whoPoint[i] = num;
            if (Graph.get(i).contains(num)) {
                continue;
            }
            countAdj[i]++;
            countAdj[num]++;
            Graph.get(i).add(num);
            Graph.get(num).add(i);
        }

        // grouping
        ArrayList<ArrayList<Integer>> Grouping = new ArrayList<ArrayList<Integer>>();
        int grouping = 0;
        for (int i = 1; i <= N; i++) {
            if (groupNumber[i] == 0) {
                dfs(i, ++grouping);
            }
        }
        for (int i = 0; i <= grouping; i++) {
            Grouping.add(new ArrayList<>());
        }
        for (int i = 1; i <= N; i++) {
            Grouping.get(groupNumber[i]).add(i);
        }

        // bfs init => leadfNode add
        Queue<Integer> queue = new LinkedList<Integer>();
        for (int i = 1; i <= N; i++) {
            if (countAdj[i] <= 1) {
                queue.offer(i);
                check[i] = true;
            }
        }

        // cycle ì—¬ë¶€ í™•ì¸
        for (int i = 1; i <= grouping; i++) {
            boolean isCycle = true;
            for (Integer j : Grouping.get(i)) {
                if (countAdj[j] != 2) {
                    isCycle = false;
                }
            }
            if (isCycle) {
                queue.offer(Grouping.get(i).get(0));
                check[Grouping.get(i).get(0)] = true;
            }
        }

        // find Mafia
        int answer = 0;
        boolean[] isCitizen = new boolean[N + 1];
        while (!queue.isEmpty()) {
            int node = queue.poll();
            if (isCitizen[node]) {
                continue;
            }
            answer++;
            for (Integer i : Graph.get(node)) {
                if (isCitizen[i]) {
                    continue;
                }
                isCitizen[i] = true;
                for (Integer j : Graph.get(i)) {
                    if (isCitizen[j] || check[j]) {
                        continue;
                    }
                    countAdj[j]--;
                    if (countAdj[j] <= 1) {
                        check[j] = true;
                        queue.offer(j);
                    }
                }
            }
        }
        System.out.println(answer);
        br.close();
    }
}
```

## ğŸ’ª í’€ì´ ë°©ë²•

1. ì§€ëª©í•œ ì‚¬ëŒì´ ëˆ„êµ°ì§€ë¥¼ í•œ ë°©í–¥ ê°„ì„ ìœ¼ë¡œ ê·¸ë¦° ê·¸ë˜í”„ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
2. ì´ í›„ ì•„ë¬´ì—ê²Œë„ ì§€ëª© ë°›ì§€ ì•Šì€ ì‚¬ëŒì€ ë¬´ì¡°ê±´ ë§ˆí”¼ì•„ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.
3. ë§ˆí”¼ì•„ê°€ ì§€ëª©í•œ ì‚¬ëŒì€ ë¬´ì¡°ê±´ ì‹œë¯¼ì…ë‹ˆë‹¤.
4. ë§ˆí”¼ì•„ëŠ” ë§ˆí”¼ì•„ë¼ë¦¬ ì§€ëª©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë¯€ë¡œ ì§€ëª©í•˜ëŠ” ì‚¬ëŒì´ ëª¨ë‘ ì‹œë¯¼ì´ë©´ ê·¸ ì‚¬ëŒì€ ë§ˆí”¼ì•„ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.

## ğŸ‘» About

1. ëª¨ë“  ì¸ì ‘ ë…¸ë“œê°€ ì‹œë¯¼ì´ë©´ ë§ˆí”¼ì•„ê°€ ê°€ëŠ¥
2. ì¸ì ‘ ë…¸ë“œ ì¤‘ í•œ ëª…ì´ë¼ë„ ë§ˆí”¼ì•„ë©´ ë¬´ì¡°ê±´ ì‹œë¯¼

## âœˆ Explain Code

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

class Main {
    public static int[] whoPoint, countAdj;
    public static boolean[] visited, isMafia;

    public static void CheckMafia(int i, boolean isFind) {
        if (visited[i])
            return; // ì´ì „ ë°©ë¬¸í•œ ë…¸ë“œëŠ” ì œì™¸
        if (isFind) {
            isMafia[i] = true; // isFindê°€ trueë©´ ë§ˆí”¼ì•„ì…ë‹ˆë‹¤.
        }
        visited[i] = true;
        countAdj[whoPoint[i]]--;
        if (countAdj[whoPoint[i]] == 0 || isFind) {
            CheckMafia(whoPoint[i], !isFind);
        }
        // 1. ëª¨ë“  ì¸ì ‘ ë…¸ë“œê°€ ì‹œë¯¼ì´ë©´ ë§ˆí”¼ì•„ê°€ ê°€ëŠ¥
        // 2. ì¸ì ‘ ë…¸ë“œ ì¤‘ í•œ ëª…ì´ë¼ë„ ë§ˆí”¼ì•„ë©´ ë¬´ì¡°ê±´ ì‹œë¯¼
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());
        whoPoint = new int[N + 1]; // ëˆ„êµ¬ë¥¼ ì§€ëª©í–ˆëŠ”ì§€ ì €ì¥
        countAdj = new int[N + 1]; // ì¸ì ‘ ë…¸ë“œ ìˆ˜ ì €ì¥
        visited = new boolean[N + 1]; // ë°©ë¬¸ ì—¬ë¶€ ì €ì¥
        isMafia = new boolean[N + 1]; // ë§ˆí”¼ì•„ ìœ ë¬´ ì €ì¥
        for (int i = 1; i <= N; i++) {
            int num = Integer.parseInt(br.readLine());
            whoPoint[i] = num;
            countAdj[num]++;
        }
        for (int i = 1; i <= N; i++) {
            if (countAdj[i] == 0) {
                CheckMafia(i, true);
            } // ì•„ë¬´ë„ ì§€ëª©ì„ ë°›ì§€ ì•Šì€ ì‚¬ëŒì€ ë¬´ì¡°ê±´ ë§ˆí”¼ì•„ ê°€ëŠ¥
        }
        for (int i = 1; i <= N; i++) {
            CheckMafia(i, false);
        } // ë§ˆí”¼ì•„ëŠ” ì¸ì ‘ ë…¸ë“œê°€ ë¬´ì¡°ê±´ ì‹œë¯¼ì´ì–´ì•¼ í•©ë‹ˆë‹¤.
        int result = 0;
        for (int i = 1; i <= N; i++) {
            if (isMafia[i])
                result++;
        } // ê²°ê³¼ê°’ ë„ì¶œ
        System.out.println(result);
        br.close();
    }
}
```

## âœˆ Source Code

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

class Main {
    public static int[] whoPoint, countAdj;
    public static boolean[] visited, isMafia;

    public static void CheckMafia(int i, boolean isFind) {
        if (visited[i])
            return;
        if (isFind) {
            isMafia[i] = true;
        }
        visited[i] = true;
        countAdj[whoPoint[i]]--;
        if (countAdj[whoPoint[i]] == 0 || isFind) {
            CheckMafia(whoPoint[i], !isFind);
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());
        whoPoint = new int[N + 1];
        countAdj = new int[N + 1];
        visited = new boolean[N + 1];
        isMafia = new boolean[N + 1];
        for (int i = 1; i <= N; i++) {
            int num = Integer.parseInt(br.readLine());
            whoPoint[i] = num;
            countAdj[num]++;
        }
        for (int i = 1; i <= N; i++) {
            if (countAdj[i] == 0) {
                CheckMafia(i, true);
            }
        }
        for (int i = 1; i <= N; i++) {
            CheckMafia(i, false);
        }
        int result = 0;
        for (int i = 1; i <= N; i++) {
            if (isMafia[i])
                result++;
        }
        System.out.println(result);
        br.close();
    }
}
```

## âœ” íšŒê³ 

ë¬¸ì œ ê°ì´ ì•ˆ ì˜¬ ë•ŒëŠ” ì˜ˆì œ ìƒí™©ì„ ê·¸ë ¤ê°€ë©´ì„œ ì´í•´í•©ì‹œë‹¤!
