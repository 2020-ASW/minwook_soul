# ğŸ“• Solution

## ğŸ“‘ ë¬¸ì œ ì„¤ëª…

1. ì¡´ì€ ì¶•ì‚¬ë¥¼ Mê°œì˜ ì¹¸ìœ¼ë¡œ êµ¬ë¶„í•˜ê³ , í•œ ì¹¸ì—ëŠ” ìµœëŒ€ í•œ ë§ˆë¦¬ì˜ ì†Œë§Œ ë“¤ì–´ê°€ê²Œ ê³„íší–ˆë‹¤.

2. ì†Œê°€ ìì‹ ì´ í¬ë§í•˜ëŠ” ëª‡ ê°œì˜ ì¶•ì‚¬ ì™¸ì—ëŠ” ë“¤ì–´ê°€ê¸°ë¥¼ ê±°ë¶€í•˜ëŠ” ê²ƒì´ë‹¤. ë†ë¶€ ì¡´ì„ ë„ì™€ ìµœëŒ€í•œ ë§ì€ ìˆ˜ì˜ ì†Œê°€ ì¶•ì‚¬ì— ë“¤ì–´ê°ˆ ìˆ˜ ìˆë„ë¡ í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.

3. ì¶•ì‚¬ì˜ ë²ˆí˜¸ëŠ” 1ë¶€í„° Mê¹Œì§€ ë§¤ê²¨ì ¸ ìˆë‹¤.

## ğŸ‘» ì ‘ê·¼ ë°©ì‹

ìµœëŒ€í•œ ë§ì´ ë“¤ì–´ê°€ì•¼ í•˜ëŠ” ê²ƒì€ ë‹¤ë¥¸ ë§ë¡œ ì–˜ê¸°í•˜ë©´ Nê°œì˜ ì†Œê°€ ê²¹ì¹˜ì§€ ì•Šê³  Mê°œì˜ ì¶•ì‚¬ì— ë“¤ì–´ê°€ì•¼ í•˜ê³  ì¤‘ë³µì„ ì œê±°í•˜ê³ , ì›í•˜ëŠ” ìš©ëŸ‰ë§Œí¼ ì±„ìš¸ ìˆ˜ ìˆëŠ” ì•Œê³ ë¦¬ì¦˜ì€ `ë„¤íŠ¸ì›Œí¬ í”Œë¡œìš°` ë°–ì— ì—†ë‹¤ê³  ìƒê°í–ˆìŠµë‹ˆë‹¤.

graphëŠ” ì•„ë˜ì™€ ê°™ì´ ê·¸ë¦´ ìˆ˜ ìˆë‹¤ê³  ìƒê°í–ˆìŠµë‹ˆë‹¤. ì•„ë˜ ê·¸ë¦¼ì€ ì˜ˆì œë¥¼ ë”°ë¼ ê·¸ë¦° ê·¸ë˜í”„ì…ë‹ˆë‹¤.

[![](https://mermaid.ink/img/eyJjb2RlIjoic3RhdGVEaWFncmFtLXYyXG4gICAgU3RhcnQgLS0-IGNvdzFcbiAgICBTdGFydCAtLT4gY293MlxuICAgIFN0YXJ0IC0tPiBjb3czXG4gICAgU3RhcnQgLS0-IGNvdzRcbiAgICBTdGFydCAtLT4gY293NVxuICAgIEJhcm4xIC0tPiBFbmRcbiAgICBCYXJuMiAtLT4gRW5kXG4gICAgQmFybjMgLS0-IEVuZFxuICAgIEJhcm40IC0tPiBFbmRcbiAgICBCYXJuNSAtLT4gRW5kXG4gICAgY293MSAtLT4gQmFybjJcbiAgICBjb3cxIC0tPiBCYXJuNVxuICAgIGNvdzIgLS0-IEJhcm4yXG4gICAgY293MiAtLT4gQmFybjNcbiAgICBjb3cyIC0tPiBCYXJuNFxuICAgIGNvdzMgLS0-IEJhcm4xXG4gICAgY293MyAtLT4gQmFybjVcbiAgICBjb3c0IC0tPiBCYXJuMVxuICAgIGNvdzQgLS0-IEJhcm4yXG4gICAgY293NCAtLT4gQmFybjVcbiAgICBjb3c1IC0tPiBCYXJuMiIsIm1lcm1haWQiOnsidGhlbWUiOiJkZWZhdWx0In0sInVwZGF0ZUVkaXRvciI6ZmFsc2V9)](https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic3RhdGVEaWFncmFtLXYyXG4gICAgU3RhcnQgLS0-IGNvdzFcbiAgICBTdGFydCAtLT4gY293MlxuICAgIFN0YXJ0IC0tPiBjb3czXG4gICAgU3RhcnQgLS0-IGNvdzRcbiAgICBTdGFydCAtLT4gY293NVxuICAgIEJhcm4xIC0tPiBFbmRcbiAgICBCYXJuMiAtLT4gRW5kXG4gICAgQmFybjMgLS0-IEVuZFxuICAgIEJhcm40IC0tPiBFbmRcbiAgICBCYXJuNSAtLT4gRW5kXG4gICAgY293MSAtLT4gQmFybjJcbiAgICBjb3cxIC0tPiBCYXJuNVxuICAgIGNvdzIgLS0-IEJhcm4yXG4gICAgY293MiAtLT4gQmFybjNcbiAgICBjb3cyIC0tPiBCYXJuNFxuICAgIGNvdzMgLS0-IEJhcm4xXG4gICAgY293MyAtLT4gQmFybjVcbiAgICBjb3c0IC0tPiBCYXJuMVxuICAgIGNvdzQgLS0-IEJhcm4yXG4gICAgY293NCAtLT4gQmFybjVcbiAgICBjb3c1IC0tPiBCYXJuMiIsIm1lcm1haWQiOnsidGhlbWUiOiJkZWZhdWx0In0sInVwZGF0ZUVkaXRvciI6ZmFsc2V9)

## ğŸ‘» About

startì—ì„œ endë¡œ íë¥¼ ë•Œ, ì–¼ë§ˆë‚˜ íë¥´ëŠ”ì§€ë§Œ íŒë‹¨í•˜ë©´ ë©ë‹ˆë‹¤.

## âœˆ Explain Code

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.StringTokenizer;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Arrays;
import java.util.Queue;

class Main {
    public static int n, size, result;
    public static int[] distance, row, column;
    public static int[][] capacity, flow, arr;
    public static ArrayList<ArrayList<Integer>> graph;

    public static void addEdge(int a, int b, int c) {
        graph.get(a).add(b);
        graph.get(b).add(a);
        capacity[a][b] = c;
    } // graph ê°„ì„  ì¶”ê°€

    public static void maxFlow(int start, int end) {
        while (true) {
            Arrays.fill(distance, -1); // -1ì€ ë°©ë¬¸í•˜ì§€ ì•Šì•˜ë‹¤ëŠ” ì˜ë¯¸
            Queue<Integer> queue = new LinkedList<Integer>();
            queue.offer(start);
            while (!queue.isEmpty() && distance[end] == -1) {
                int x = queue.poll();
                for (int i = 0; i < graph.get(x).size(); i++) {
                    int y = graph.get(x).get(i);
                    if (capacity[x][y] - flow[x][y] > 0 && distance[y] == -1) {
                        queue.add(y);
                        distance[y] = x; // ê²½ë¡œë¥¼ ê¸°ì–µí•©ë‹ˆë‹¤.
                    } // ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œ ì¤‘ì— ìš©ëŸ‰ì´ ë‚¨ì€ ê²½ìš°
                }
            }
            if (distance[end] == -1) {
                break;
            } // ëª¨ë“  ê²½ë¡œë¥¼ ì°¾ì€ ë’¤ì— ì¢…ë£Œ
            int Flow = Integer.MAX_VALUE;
            for (int i = end; i != start; i = distance[i]) {
                Flow = Math.min(Flow, capacity[distance[i]][i] - flow[distance[i]][i]);
            } // ê±°ê¾¸ë¡œ ìµœì†Œ ìœ ëŸ‰ íƒìƒ‰
            for (int i = end; i != start; i = distance[i]) {
                flow[distance[i]][i] += Flow;
                flow[i][distance[i]] -= Flow;
            }
            result += Flow;
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st = new StringTokenizer(br.readLine(), " ");
        int N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());
        int start = 0, end = N + M + 1, size = end + 1;
        // ì†ŒëŠ” 1 ~ N, ì¶•ì‚¬ëŠ” N + 1 ~ N + M;
        capacity = new int[size + 1][size + 1];
        flow = new int[size + 1][size + 1];
        distance = new int[size + 1];
        graph = new ArrayList<>();
        for (int i = 0; i <= size; i++) {
            graph.add(new ArrayList<>());
        }
        for (int i = 1; i <= N; i++) {
            addEdge(start, i, 1);
        }
        for (int i = N + 1; i <= N + M; i++) {
            addEdge(i, end, 1);
        }
        for (int i = 1; i <= N; i++) {
            st = new StringTokenizer(br.readLine(), " ");
            int K = Integer.parseInt(st.nextToken());
            for (int j = 0; j < K; j++) {
                int num = Integer.parseInt(st.nextToken());
                addEdge(i, num + N, 1);
            }
        }
        result = 0;
        maxFlow(start, end);
        System.out.println(result);
        br.close();
        bw.close();
    }
}
```

## âœˆ Source Code

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.StringTokenizer;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Arrays;
import java.util.Queue;

class Main {
    public static int n, size, result;
    public static int[] distance, row, column;
    public static int[][] capacity, flow, arr;
    public static ArrayList<ArrayList<Integer>> graph;

    public static void addEdge(int a, int b, int c) {
        graph.get(a).add(b);
        graph.get(b).add(a);
        capacity[a][b] = c;
    }

    public static void maxFlow(int start, int end) {
        while (true) {
            Arrays.fill(distance, -1);
            Queue<Integer> queue = new LinkedList<Integer>();
            queue.offer(start);
            while (!queue.isEmpty() && distance[end] == -1) {
                int x = queue.poll();
                for (int i = 0; i < graph.get(x).size(); i++) {
                    int y = graph.get(x).get(i);
                    if (capacity[x][y] - flow[x][y] > 0 && distance[y] == -1) {
                        queue.add(y);
                        distance[y] = x;
                    }
                }
            }
            if (distance[end] == -1) {
                break;
            }
            int Flow = Integer.MAX_VALUE;
            for (int i = end; i != start; i = distance[i]) {
                Flow = Math.min(Flow, capacity[distance[i]][i] - flow[distance[i]][i]);
            }
            for (int i = end; i != start; i = distance[i]) {
                flow[distance[i]][i] += Flow;
                flow[i][distance[i]] -= Flow;
            }
            result += Flow;
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st = new StringTokenizer(br.readLine(), " ");
        int N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());
        int start = 0, end = N + M + 1, size = end + 1;
        capacity = new int[size + 1][size + 1];
        flow = new int[size + 1][size + 1];
        distance = new int[size + 1];
        graph = new ArrayList<>();
        for (int i = 0; i <= size; i++) {
            graph.add(new ArrayList<>());
        }
        for (int i = 1; i <= N; i++) {
            addEdge(start, i, 1);
        }
        for (int i = N + 1; i <= N + M; i++) {
            addEdge(i, end, 1);
        }
        for (int i = 1; i <= N; i++) {
            st = new StringTokenizer(br.readLine(), " ");
            int K = Integer.parseInt(st.nextToken());
            for (int j = 0; j < K; j++) {
                int num = Integer.parseInt(st.nextToken());
                addEdge(i, num + N, 1);
            }
        }
        result = 0;
        maxFlow(start, end);
        System.out.println(result);
        br.close();
        bw.close();
    }
}
```

## âœ” íšŒê³ 

ë„¤íŠ¸ì›Œí¬ í”Œë¡œìš° ë¬¸ì œëŠ” ì•Œê³ ë¦¬ì¦˜ì´ ë¹„ìŠ·í•˜êµ¬ë‚˜ë¼ëŠ” ê²ƒì„ ëŠê¼ˆìŠµë‹ˆë‹¤.
