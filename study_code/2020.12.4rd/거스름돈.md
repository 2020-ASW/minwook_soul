# 📕 거스름돈

## :memo:문제 설명

1. Finn은 손님들께 거스름돈을 n 원을 줄 때 방법의 경우의 수를 구하기로 하였습니다.
2. 거슬러 줘야 하는 금액 n과 Finn이 현재 보유하고 있는 돈의 종류 money가 매개변수로 주어질 때, Finn이 n 원을 거슬러 줄 방법의 수를 return 하도록 solution 함수를 완성해 주세요.
3. 정답이 커질 수 있으니, 1,000,000,007로 나눈 나머지를 return 해주세요.

Ex) 예를 들어서 손님께 5원을 거슬러 줘야 하고 1원, 2원, 5원이 있다면 다음과 같이 4가지 방법으로 5원을 거슬러 줄 수 있습니다.

- 1원을 5개 사용해서 거슬러 준다.
- 1원을 3개 사용하고, 2원을 1개 사용해서 거슬러 준다.
- 1원을 1개 사용하고, 2원을 2개 사용해서 거슬러 준다.
- 5원을 1개 사용해서 거슬러 준다.

▶ 이 예시를 기준으로 설명하겠습니다!

## 💪풀이 방법

0. 일단 3원을 거슬러 줘야하고 1원, 2원이 있다고 가정하면, (1, 2), (1, 1, 1)로 1원 + (2원을 거슬러 줘야하고 1원, 2원이 있다고 가정하는 경우의 수(=(2),(1,1)))를 더한 것과 비슷하다고 생각했습니다. 그래서 이건 무조건 n원에 따라 영향을 받는 knapsack problem이랑 많이 유사할 것이다라고 생각했습니다.

- knapsack problem: [**Go to link**](https://gsmesie692.tistory.com/113)

1. knapsack문제는 dp이고 `dp[money의 경우의 수 + 1][n + 1]`에 해당되는 배열을 선언해줍니다.
2. dp배열이 어떻게 채워지는지 확인해봅니다.

2-1. 배열 선언 && dp[0][0] = 1 선언

|     |     |     |     |     |     |
| :-: | :-: | :-: | :-: | :-: | :-: |
|  1  |  0  |  0  |  0  |  0  |  0  |
|  0  |  0  |  0  |  0  |  0  |  0  |
|  0  |  0  |  0  |  0  |  0  |  0  |
|  0  |  0  |  0  |  0  |  0  |  0  |

2-2. 1원을 사용하는 경우, 다 경우의 수 1개로 동일
Ex) `dp[1][3]`은 3원을 거슬러 줘야하고 1원 있다고 가정하는 경우의 수

|     |     |     |     |     |     |
| :-: | :-: | :-: | :-: | :-: | :-: |
|  1  |  0  |  0  |  0  |  0  |  0  |
|  1  |  1  |  1  |  1  |  1  |  1  |
|  0  |  0  |  0  |  0  |  0  |  0  |
|  0  |  0  |  0  |  0  |  0  |  0  |

2-3. 2원을 사용하는 경우, 3가지 경우로 나누어집니다.  
n원이 2원보다 낮은 경우, 이전 행렬의 수와 동일할 것입니다. `dp[2][n] = dp[1][n]`  
n원이 2원인 경우, 이전 행렬의 수에 1을 더해줘야합니다. `dp[2][n] = dp[1][n] + 1`  
n원이 2원보다 높은 경우, 이전 행렬의 수와 n - 2원을 거슬러 줘야하고 1, 2원 있다고 가정하는 경우의 수를 더한 경우를 더해주는 수와 같습니다. `dp[2][n] = dp[1][n] + dp[2][n - 2]`

|     |     |     |     |     |     |
| :-: | :-: | :-: | :-: | :-: | :-: |
|  1  |  0  |  0  |  0  |  0  |  0  |
|  1  |  1  |  1  |  1  |  1  |  1  |
|  1  |  1  |  2  |  2  |  3  |  3  |
|  0  |  0  |  0  |  0  |  0  |  0  |

2-4. 5원을 사용하는 경우도 동일합니다.

|     |     |     |     |     |     |
| :-: | :-: | :-: | :-: | :-: | :-: |
|  1  |  0  |  0  |  0  |  0  |  0  |
|  1  |  1  |  1  |  1  |  1  |  1  |
|  1  |  1  |  2  |  2  |  3  |  3  |
|  1  |  1  |  2  |  2  |  3  |  4  |

### Source Code

```java
import java.util.Arrays;

class Solution {
    public static final int Mod = 1000000007;
    public int solution(int n, int[] money) {
        Arrays.sort(money);
        int[][] dp = new int[money.length + 1][n + 1];
        int x_size = n + 1 , y_size = money.length + 1;
        dp[0][0] = 1;
        for(int i = 1; i < y_size; i++){
            for(int j = 0 ; j < x_size; j++){
                if(j == money[i - 1]){
                    dp[i][j] = (dp[i - 1][j] + 1) % Mod;
                } else if(j < money[i - 1]){
                    dp[i][j] = dp[i - 1][j] % Mod;
                } else if(j > money[i - 1]){
                    dp[i][j] = (dp[i - 1][j] + dp[i][j - money[i - 1]]) % Mod;
                }
            }
        }
        return dp[money.length][n];
    }
}
```

**통과했지만 최소 50.16ms가 나올 정도로, 느립니다.😢**

## 👻또 다른 접근 방식

**Ex)** 2-3. 2원을 사용하는 경우, 3가지 경우로 나누어집니다.  
n원이 2원보다 낮은 경우, 이전 행렬의 수와 동일할 것입니다. `dp[2][n] = dp[1][n]`  
n원이 2원인 경우, 이전 행렬의 수에 1을 더해줘야합니다. `dp[2][n] = dp[1][n] + 1`  
n원이 2원보다 높은 경우, 이전 행렬의 수와 n - 2원을 거슬러 줘야하고 1, 2원 있다고 가정하는 경우의 수를 더한 경우를 더해주는 수와 같습니다. `dp[2][n] = dp[1][n] + dp[2][n - 2]`

▶ 이와 같은 경우에서 굳이 n원이 2보다 낮은 경우를 해줄 이유가 있나? 그리고 메모리 공간을 먼저 설정해야 하는 건가?

- 이 고민을 해결하는 방법으로 `dp[n + 1]`로 선언해서 money배열를 확인하면서 값을 바꿔줍니다.
- n원이 `money[i]`보다 낮은 경우는 계산하지 않습니다.

Ex) 2원을 사용하는 경우

|     |     |     |     |     |     |
| :-: | :-: | :-: | :-: | :-: | :-: |
|  1  |  1  |  1  |  1  |  1  |  1  |

🔽

|     |     |     |     |     |     |
| :-: | :-: | :-: | :-: | :-: | :-: |
|  1  |  1  |  2  |  2  |  3  |  3  |

### Source Code

```java
import java.util.Arrays;

class Solution {
    public static final int Mod = 1000000007;
    public int solution(int n, int[] money) {
        Arrays.sort(money);
        int[] dp = new int[n + 1];
        dp[0] = 1;
        for(Integer element : money){
            for(int j = element; j < n + 1; j++){
                dp[j] = (dp[j] + dp[j - element]) % Mod;
            }
        }
        return dp[n];
    }
}
```

**통과했고 최소 14.53ms로 빠릅니다!😃**

### ✔ 회고

구현은 쉽게 했는데, 시간 줄이는건 이틀 넘게 걸렸습니다....😑😑
