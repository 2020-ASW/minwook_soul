# ğŸ“• Solution

## :memo: ë¬¸ì œ ì„¤ëª…

1. nÃ—nì§œë¦¬ì˜ ë°°ì—´ì—ì„œ (1, 1)ì—ì„œ (n, n)ê¹Œì§€ ì´ë™í•˜ë ¤ê³  í•©ë‹ˆë‹¤.
2. ì´ë™í•  ë•ŒëŠ” ìƒ, í•˜, ì¢Œ, ìš°ì˜ ë„¤ ì¸ì ‘í•œ ì¹¸ìœ¼ë¡œë§Œ ì´ë™í•  ìˆ˜ ìˆë‹¤.
3. ì´ë™í•˜ê¸° ìœ„í•´ ê±°ì³ ê°„ ìˆ˜ë“¤ ì¤‘ ìµœëŒ“ê°’ê³¼ ìµœì†Ÿê°’ì˜ ì°¨ì´ê°€ ê°€ì¥ ì‘ì•„ì§€ëŠ” ìµœì†Œê°’ì„ ë°˜í™˜í•˜ì„¸ìš”.

## ğŸ‘» ì ‘ê·¼ ë°©ì‹

1. (1, 1)ì—ì„œ dfsë¥¼ ì ìš©ì‹œí‚¨ ë‹¤ìŒ, (n, n)ê¹Œì§€ ê°€ëŠ” ê²½ìš°, í•´ë‹¹ ê²½ë¡œë¥¼ listì— ì¼ì¼ì´ ì €ì¥í•´ì„œ binary Searchë¥¼ ì´ìš©í•´ì„œ ìµœëŒ“ê°’ê³¼ ìµœì†Ÿê°’ì„ ì°¨ì´ë¥¼ êµ¬í•©ë‹ˆë‹¤. </br>
   ê²°ê³¼ : ë©”ëª¨ë¦¬ ì´ˆê³¼ â–¶ [**Fail_dfs_list_error**](##âŒfail_dfs_list_error)

2. (1, 1)ì—ì„œ bfsë¥¼ ì ìš©ì‹œí‚¨ ë‹¤ìŒ, (n, n)ê¹Œì§€ ê°€ëŠ” ê²½ìš°, í•´ë‹¹ ì¢Œí‘œì— í•´ë‹¹ë˜ëŠ” ìµœëŒ“ê°’ê³¼ ìµœì†Ÿê°’ì„ ê°±ì‹ í•˜ë©´ì„œ (n, n)ê¹Œì§€ ì´ë™í•©ë‹ˆë‹¤. </br>
   ê²°ê³¼ : ì‹œê°„ ì´ˆê³¼ â–¶ [**Fail_bfs_Runtime_error**](##âŒfail_bfs_Runtime_error)

3. ìš°ì„ ì ìœ¼ë¡œ ì…ë ¥ê°’ì„ ì €ì¥í•˜ë©´ì„œ ì…ë ¥ê°’ì˜ ì¢…ë¥˜ë¥¼ listì— ì €ì¥í•©ë‹ˆë‹¤. </br> ë‹¤ìŒ ìµœì†Ÿê°’(=MIN)ì™€ ìµœëŒ“ê°’(=MAX)ì„ ì •í•´ì„œ í•´ë‹¹ ë²”ìœ„ì˜ ìˆ«ìë¡œ (1,1)ì—ì„œ (n,n)ê¹Œì§€ ê°ˆ ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤. ê°€ëŠ¥í•˜ë‹¤ë©´ MINì„ ì¦ê°€í•˜ê³  ë¶ˆê°€ëŠ¥í•˜ë‹¤ë©´ MAXë¥¼ ì¦ê°€í•©ë‹ˆë‹¤.

4. í•´ë‹¹ ë²”ìœ„ë¡œ ì´ë™ì´ ê°€ëŠ¥í•œì§€ í™•ì¸í•˜ëŠ” ë°©ë²•ìœ¼ë¡œ bfsë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. </br> (1, 1)ì—ì„œ bfsë¥¼ ì ìš©ì‹œí‚¨ ë‹¤ìŒ, (n, n)ê¹Œì§€ ê°€ëŠ” ê²½ìš°, í•´ë‹¹ ì¢Œí‘œì— í•´ë‹¹ë˜ëŠ” ê°’ì´ ë²”ìœ„ ì•ˆì— ì†í•˜ëŠ”ì§€ í™•ì¸í•˜ë©´ì„œ (n, n)ê¹Œì§€ ì´ë™í•©ë‹ˆë‹¤. </br> ê²°ê³¼ : ì‹œê°„ ì´ˆê³¼ â–¶ [**Fail_bfs_memory_error**](##âŒfail_bfs_memory_error)

## ğŸ’ª í’€ì´ ë°©ë²•

1. ì…ë ¥ê°’ì„ ì €ì¥í•˜ë©´ì„œ ì…ë ¥ê°’ì˜ ì¢…ë¥˜ë¥¼ listì— ì €ì¥í•©ë‹ˆë‹¤.
2. listì— ìˆëŠ” ìˆ˜ë¡œ ìµœì†Ÿê°’(=MIN)ì™€ ìµœëŒ“ê°’(=MAX)ì„ ì •í•´ì„œ í•´ë‹¹ ë²”ìœ„ì˜ ìˆ«ìë¡œ (1,1)ì—ì„œ (n,n)ê¹Œì§€ ê°ˆ ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤. ê°€ëŠ¥í•˜ë‹¤ë©´ MINì„ ì¦ê°€í•˜ê³  ë¶ˆê°€ëŠ¥í•˜ë‹¤ë©´ MAXë¥¼ ì¦ê°€í•©ë‹ˆë‹¤.

```java
while (start < Size && end < Size) {
    if (bfs(numberkind.get(start), numberkind.get(end))) {
        gap = numberkind.get(end) - numberkind.get(start);
        if (answer > gap)
            answer = gap;
        start++;
    } else {
        end++;
    }
}
```

3. í•´ë‹¹ ë²”ìœ„ë¡œ ì´ë™ì´ ê°€ëŠ¥í•œì§€ í™•ì¸í•˜ëŠ” ë°©ë²•ìœ¼ë¡œ bfsë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. </br> (1, 1)ì—ì„œ bfsë¥¼ ì ìš©ì‹œí‚¨ ë‹¤ìŒ, (n, n)ê¹Œì§€ ê°€ëŠ” ê²½ìš°, í•´ë‹¹ ì¢Œí‘œì— í•´ë‹¹ë˜ëŠ” ê°’ì´ ë²”ìœ„ ì•ˆì— ì†í•˜ëŠ”ì§€ í™•ì¸í•˜ë©´ì„œ (n, n)ê¹Œì§€ ì´ë™í•©ë‹ˆë‹¤. **ë°©ë¬¸í•œ ë…¸ë“œëŠ” visited[][]ë¥¼ ë¯¸ë¦¬ trueë¡œ ë°”ê¾¸ì–´ì„œ ê³„ì‚°ëŸ‰ì„ ì¤„ì—¬ì¤ë‹ˆë‹¤.**

```java
public static boolean bfs(int min, int max) {
    if (arr[0][0] < min || arr[0][0] > max) {
        return false;
    }
    Queue<Node> queue = new LinkedList<Node>();
    boolean[][] visited = new boolean[N][N];
    queue.offer(new Node(0, 0));
    visited[0][0] = true;
    while (!queue.isEmpty()) {
        Node node = queue.poll();
        if (node.x == N - 1 && node.y == N - 1) {
            return true;
        }
        for (int i = 0; i < 4; i++) {
            int nextX = node.x + X[i];
            int nextY = node.y + Y[i];
            if (nextX < 0 || nextX >= N) {
                continue;
            }
            if (nextY < 0 || nextY >= N) {
                continue;
            }
            if (visited[nextX][nextY]) {
                continue;
            }
            if (arr[nextX][nextY] >= min && arr[nextX][nextY] <= max) {
                queue.offer(new Node(nextX, nextY));
                visited[nextX][nextY] = true;
            }
        }
    }
    return false;
}
```

## ğŸ‘» About

ì•„ë˜ ì½”ë“œì™€ ê°™ì´ ë¯¸ë¦¬ `visited[nextX][nextY] = true;`ë¥¼ í•´ì¤˜ì„œ ê³„ì‚°ëŸ‰ì„ ì¤„ì´ëŠ” ê²ƒì´ ì¤‘ìš”í•©ë‹ˆë‹¤.

```java
if (arr[nextX][nextY] >= min && arr[nextX][nextY] <= max) {
    queue.offer(new Node(nextX, nextY));
    visited[nextX][nextY] = true;
}
```

## âœˆ Explain Code

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

class Main {
    static class Node {
        int x;
        int y;

        Node(int x, int y) {
            this.x = x;
            this.y = y;
        }
    } // Node ì„¤ì •

    private static int N;
    private static int[][] arr;
    private static final int[] X = { 1, 0, -1, 0 };
    private static final int[] Y = { 0, 1, 0, -1 }; // ìƒí•˜ì¢Œìš° ì„¤ì •

    public static boolean bfs(int min, int max) {
        if (arr[0][0] < min || arr[0][0] > max) {
            return false;
        }
        Queue<Node> queue = new LinkedList<Node>();
        boolean[][] visited = new boolean[N][N];
        queue.offer(new Node(0, 0));
        visited[0][0] = true;
        while (!queue.isEmpty()) {
            Node node = queue.poll();
            if (node.x == N - 1 && node.y == N - 1) {
                return true; //(n,n) ë„ì°©ì‹œ return true;
            }
            for (int i = 0; i < 4; i++) {
                int nextX = node.x + X[i];
                int nextY = node.y + Y[i];
                if (nextX < 0 || nextX >= N) {
                    continue;
                }
                if (nextY < 0 || nextY >= N) {
                    continue;
                } // ë°°ì—´ ì•ˆì— ìˆëŠ”ì§€ í™•ì¸
                if (visited[nextX][nextY]) {
                    continue;
                } // ë°©ë¬¸í•œ ë…¸ë“œì¸ì§€ í™•ì¸
                if (arr[nextX][nextY] >= min && arr[nextX][nextY] <= max) {
                    queue.offer(new Node(nextX, nextY));
                    visited[nextX][nextY] = true;
                } // ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œì— ëŒ€í•´ queueì— ì¶”ê°€
            }
        }
        return false; //(n,n) ë„ì°©í•˜ì§€ ëª»í•  ì‹œ return false;
    }

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        N = Integer.parseInt(br.readLine());
        arr = new int[N][N];
        ArrayList<Integer> numberkind = new ArrayList<>();
        for (int i = 0; i < N; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine(), " ");
            for (int j = 0; j < N; j++) {
                arr[i][j] = Integer.parseInt(st.nextToken());
                if (!numberkind.contains(arr[i][j])) {
                    numberkind.add(arr[i][j]);
                } // ì…ë ¥ì„ ë°›ìœ¼ë©´ì„œ ì…ë ¥ê°’ì˜ ì¢…ë¥˜ë§Œ numberkindì— ì €ì¥í•©ë‹ˆë‹¤.
            }
        }
        Collections.sort(numberkind); // list sort
        int start = 0, end = 0, gap = 0, Size = numberkind.size(), answer = Integer.MAX_VALUE;
        while (start < Size && end < Size) {
            if (bfs(numberkind.get(start), numberkind.get(end))) {
                gap = numberkind.get(end) - numberkind.get(start);
                if (answer > gap)
                    answer = gap;
                start++;
            } else {
                end++;
            }
        } // ìµœì†Ÿê°’ê³¼ ìµœëŒ“ê°’ì„ ì •í•˜ë©´ì„œ ê²½ë¡œ ê°€ëŠ¥ ìœ ë¬´ë¥¼ í™•ì¸ ë° answer ê°±ì‹ 
        System.out.println(answer);
        br.close();
    }
}
```

## âœˆ Source Code

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

class Main {
    static class Node {
        int x;
        int y;

        Node(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

    private static int N;
    private static int[][] arr;
    private static final int[] X = { 1, 0, -1, 0 };
    private static final int[] Y = { 0, 1, 0, -1 };

    public static boolean bfs(int min, int max) {
        if (arr[0][0] < min || arr[0][0] > max) {
            return false;
        }
        Queue<Node> queue = new LinkedList<Node>();
        boolean[][] visited = new boolean[N][N];
        queue.offer(new Node(0, 0));
        visited[0][0] = true;
        while (!queue.isEmpty()) {
            Node node = queue.poll();
            if (node.x == N - 1 && node.y == N - 1) {
                return true;
            }
            for (int i = 0; i < 4; i++) {
                int nextX = node.x + X[i];
                int nextY = node.y + Y[i];
                if (nextX < 0 || nextX >= N) {
                    continue;
                }
                if (nextY < 0 || nextY >= N) {
                    continue;
                }
                if (visited[nextX][nextY]) {
                    continue;
                }
                if (arr[nextX][nextY] >= min && arr[nextX][nextY] <= max) {
                    queue.offer(new Node(nextX, nextY));
                    visited[nextX][nextY] = true;
                }
            }
        }
        return false;
    }

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        N = Integer.parseInt(br.readLine());
        arr = new int[N][N];
        ArrayList<Integer> numberkind = new ArrayList<>();
        for (int i = 0; i < N; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine(), " ");
            for (int j = 0; j < N; j++) {
                arr[i][j] = Integer.parseInt(st.nextToken());
                if (!numberkind.contains(arr[i][j])) {
                    numberkind.add(arr[i][j]);
                }
            }
        }
        Collections.sort(numberkind);
        int start = 0, end = 0, gap = 0, Size = numberkind.size(), answer = Integer.MAX_VALUE;
        while (start < Size && end < Size) {
            if (bfs(numberkind.get(start), numberkind.get(end))) {
                gap = numberkind.get(end) - numberkind.get(start);
                if (answer > gap)
                    answer = gap;
                start++;
            } else {
                end++;
            }
        }
        System.out.println(answer);
        br.close();
    }
}
```

## âœ” íšŒê³ 

ì…ë ¥ê°’ìœ¼ë¡œë„ ì¶©ë¶„íˆ ê³„ì‚°ëŸ‰ì„ ì¤„ì¼ ìˆ˜ ìˆêµ¬ë‚˜ë¼ëŠ” ìƒê°ì´ ë“¤ì—ˆìŠµë‹ˆë‹¤.ğŸ’ª

## âŒfail_dfs_list_error

ë¬¸ì œì  : dfsë¡œ returní•  ë•Œ, listê°€ ê°±ì‹ ì´ ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.StringTokenizer;

class Main {
    private static int answer, N;
    private static int[][] arr;
    private static final int[] X = { 1, 0, -1, 0 };
    private static final int[] Y = { 0, 1, 0, -1 };

    public static void dfs(int x, int y, ArrayList<Integer> list, boolean[][] visited) {
        int Size = list.size();
        if (Size == 0 || arr[x][y] > list.get(list.size() - 1)) {
            list.add(arr[x][y]);
        } else {
            int start = 0;
            int end = Size - 1;
            while (start < end) {
                int mid = (start + end) / 2;
                if (arr[x][y] > list.get(mid)) {
                    start = mid + 1;
                } else {
                    end = mid;
                }
            }
            list.set(end, arr[x][y]);
        }
        int num = list.get(list.size() - 1) - list.get(0);
        if (answer < num) {
            return;
        }
        if (x == N - 1 && y == N - 1) {
            if (answer > num)
                num = answer;
            return;
        }
        for (int i = 0; i < 4; i++) {
            int nextX = x + X[i];
            int nextY = y + Y[i];
            if (nextX < 0 || nextX >= N) {
                continue;
            }
            if (nextY < 0 || nextY >= N) {
                continue;
            }
            if (visited[nextX][nextY]) {
                continue;
            }
            visited[x][y] = true;
            dfs(nextX, nextY, list, visited);
            visited[x][y] = false;
        }
    }

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        N = Integer.parseInt(br.readLine());
        arr = new int[N][N];
        boolean[][] visited = new boolean[N][N];
        for (int i = 0; i < N; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine(), " ");
            for (int j = 0; j < N; j++) {
                arr[i][j] = Integer.parseInt(st.nextToken());
            }
        }
        ArrayList<Integer> list = new ArrayList<>();
        answer = Integer.MAX_VALUE;
        dfs(0, 0, list, visited);
        System.out.println(answer);
        br.close();
    }
}
```

## âŒfail_bfs_Runtime_error

ë¬¸ì œì  : bfsë¡œ ì¼ì¼ì´ ê³„ì‚°í•˜ë©´ ë„ˆë¬´ ë§ì€ ê³„ì‚°ëŸ‰ì„ ìš”êµ¬í•©ë‹ˆë‹¤.

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

class Node {
    int x;
    int y;
    int min;
    int max;

    Node(int x, int y, int min, int max) {
        this.x = x;
        this.y = y;
        this.min = min;
        this.max = max;
    }
}

class Main {
    private static int answer, N;
    private static int[][] arr;
    private static final int[] X = { 1, 0, -1, 0 };
    private static final int[] Y = { 0, 1, 0, -1 };

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        N = Integer.parseInt(br.readLine());
        arr = new int[N][N];
        boolean[][] visited = new boolean[N][N];
        for (int i = 0; i < N; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine(), " ");
            for (int j = 0; j < N; j++) {
                arr[i][j] = Integer.parseInt(st.nextToken());
            }
        }
        answer = Integer.MAX_VALUE;
        Queue<Node> queue = new LinkedList<Node>();
        queue.add(new Node(0, 0, arr[0][0], arr[0][0]));
        while (!queue.isEmpty()) {
            Node node = queue.poll();
            int x = node.x;
            int y = node.y;
            int min = node.min;
            int max = node.max;
            visited[x][y] = true;
            if (arr[x][y] < min) {
                min = arr[x][y];
            }
            if (arr[x][y] > max) {
                max = arr[x][y];
            }
            if (x == N - 1 && y == N - 1) {
                if (answer > max - min)
                    answer = max - min;
                continue;
            }
            for (int i = 0; i < 4; i++) {
                int nextX = x + X[i];
                int nextY = y + Y[i];
                if (nextX < 0 || nextX >= N) {
                    continue;
                }
                if (nextY < 0 || nextY >= N) {
                    continue;
                }
                if (visited[nextX][nextY]) {
                    continue;
                }
                queue.add(new Node(nextX, nextY, min, max));
            }
        }
        System.out.println(answer);
        br.close();
    }
}
```

## âŒfail_bfs_memory_error

ë¬¸ì œì  : bfsì—ì„œ Nodeë¥¼ ìƒì„±í•˜ëŠ” ê²ƒì´ ë§ì•„ ë©”ëª¨ë¦¬ ì´ˆê³¼ê°€ ìƒê¹ë‹ˆë‹¤.

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

class Main {
    static class Node {
        int x;
        int y;

        Node(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

    private static int N;
    private static int[][] arr;
    private static final int[] X = { 1, 0, -1, 0 };
    private static final int[] Y = { 0, 1, 0, -1 };

    public static boolean bfs(int min, int max) {
        if (arr[0][0] < min || arr[0][0] > max) {
            return false;
        }
        Queue<Node> queue = new LinkedList<Node>();
        boolean[][] visited = new boolean[N][N];
        queue.add(new Node(0, 0));
        visited[0][0] = true;
        while (!queue.isEmpty()) {
            Node node = queue.poll();
            int a = node.x;
            int b = node.y;
            if (a == N - 1 && b == N - 1) {
                return true;
            }
            visited[a][b] = true;
            for (int i = 0; i < 4; i++) {
                int nextX = a + X[i];
                int nextY = b + Y[i];
                if (nextX < 0 || nextX >= N) {
                    continue;
                }
                if (nextY < 0 || nextY >= N) {
                    continue;
                }
                if (visited[nextX][nextY]) {
                    continue;
                }
                if (arr[a][b] >= min && arr[a][b] <= max) {
                    queue.add(new Node(nextX, nextY));
                }
            }
        }
        return false;
    }

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        N = Integer.parseInt(br.readLine());
        arr = new int[N][N];
        ArrayList<Integer> numberkind = new ArrayList<>();
        for (int i = 0; i < N; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine(), " ");
            for (int j = 0; j < N; j++) {
                arr[i][j] = Integer.parseInt(st.nextToken());
                if (!numberkind.contains(arr[i][j])) {
                    numberkind.add(arr[i][j]);
                }
            }
        }
        Collections.sort(numberkind);
        int start = 0, end = 0, gap = 0, Size = numberkind.size(), answer = Integer.MAX_VALUE;
        while (start < Size && end < Size) {
            if (bfs(numberkind.get(start), numberkind.get(end))) {
                gap = numberkind.get(end) - numberkind.get(start);
                if (answer > gap)
                    answer = gap;
                start++;
            } else {
                end++;
            }
        }
        System.out.println(answer);
        br.close();
    }
}
```
